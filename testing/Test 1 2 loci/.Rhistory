Copyright (C) 20010 David J Balding, University College London.#
# Version 1.0 19/1/10#
# Version 1.1 23/1/10 restructured code to make it more similar to LR2unk.R#
#
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details see <http://www.gnu.org/licenses/>.#
#
# The file LR1unk.R gives R functions for evaluating numerator and denominator of the single-locus LR for the hypothesis that a given, profiled individual (ss) is the unknown contributor to the crime scene profile (csp), versus another unprofiled individual (who may be related to ss).#
# We assume exactly one unknown contributor but there can be any number of known contributors (whose alleles are masking alleles).#
# Multiple replicates are accommodated; currently dropout and dropin rates must be the same for each replicate, but this would not be hard to alter.#
# There is no upper limit on the number of dropout or dropin alleles; it would be unusual to have more than one or two dropins at any locus, or more than say three or four in the profile; otherwise the hypothesis of another unknown contributor may be more realistic than multiple dropins; in practice cc is small and so penalises multiple dropins.#
# Alleles are passed as names (character strings) and converted into indicator vectors#
#
# For further details see the paper:#
#
# Balding DJ, Buckleton J, Interpreting low template DNA profiles, Forensic Science International: Genetics, 4: 1-10, 2009, doi: 10.1016/j.fsigen.2009.03.003#
#
# Relatedness and replicates were not discussed in the FSIG paper, these are later addition. #
#
#KEL: 11/18/12, added a  function to check for allles with counts <5 in the database and alleles in ss or cp that are not in the database#
#this function sets these alleles to a count of 5.#
rare_adjust = function(all_check,n)#
{#
#
        #first make sure all alleles in "all_check" are in the database, if not, add them:#
        n2<-n[all_check]#
        names(n2)<-all_check#
        n_replace2<-ifelse(is.na(n2),5,n2)#
        n[all_check]<-n_replace2#
#
        #make sure all alleles have count >5 in database:#
        n_replace<-ifelse(n[all_check]>5,n[all_check],5)#
        n[all_check]<-n_replace#
        n#
}#
p = function(n,sub){#
# Function p returns allele proportions after sampling and Fst adjustments, from a vector n of integer allele counts and a vector sub that identifies the alleles to be corrected upwards; remaining alleles are corrected downwards, and the output is a non-negative vector that sums to 1.#
# Usually sub includes the alleles of ss, and so the Fst adjustment allows for shared ancestry of ss with an alternative possible culprit.#
# I recommend Fst should be at least 0.01, and may need to be as high as 0.05 in some populations (e.g. small, isolated subpopulations of the population from which the reference database has been drawn).#
#NOte, in this version, I get rid of the sampling adjustment!#
		adj = 2; fst = 0.01#
		#if(length(sub)==1) n[sub] = n[sub]+2*adj#
		#else for(i in 1:length(sub)) n[sub[i]] = n[sub[i]] + adj#
		n = n/sum(n)*(1-fst)/(1+fst)#
		if(length(sub)==1) n[sub] = n[sub]+2*fst/(1+fst)#
		else for(i in 1:length(sub)) n[sub[i]] = n[sub[i]]+fst/(1+fst)#
		n#
}#
#
kdrop = function(a,d,k){ # returns dropout prob for k copies of an allele when the prob for a single dropout is d#
	a^(k-1)*d^k # this is a generalisation to more than two alleles of the homozygote dropout probability suggested by Balding & Buckleton (2009); there is no consensus about the best way to model multi-allele dropout, and the function given here can be replaced with another function if preferred.#
}#
#
LRnumer = function(ss,call,n,d=0.2,a=0.5,cc=0.02){#
# output: numerator of LR.#
#
# inputs:#
# ss specifies the profile of the alleged contributor; homozygotes should be coded as a scalar, heterozygotes as a vector of length 2.#
# call is a list of lists.  The length of the outer list is the number of replicates (no upper limit).  Each inner list is of length 2: [[1]] crime scene profile (csp) alleles; [[2]] masking alleles (alleles observed in the profile but that can be attributed to a known contributor or stutter).  The program assumes that the same allele is not included both in csp and in mask, but there is currently no check for this.#
# d, a, and cc control the dropout rates for heterozygotes and homozygotes, and the drop-in rate.#
#
	pp = p(n,ss); # turn allele counts into fractions with sampling and Fst adjustment #
	ccbar = (1-2*cc+cc^(1+length(pp)))/(1-cc) # probability of no drop-in, cc = pr(exactly one drop-in)#
	csp = matrix(0,length(call),length(pp)) # initiate matrix of indicators of csp alleles, 1 row per replicate#
	msk = matrix(0,length(call),length(pp)) # initiate matrix of indicators of masking alleles, 1 row per replicate#
	for(z in 1:length(call)){ # z indexes replicates#
		tmp = call[[z]][[1]] #
		if(length(tmp)>0) for(i in 1:length(tmp)) csp[z,] = csp[z,] + (names(pp) == tmp[i]) #
		tmp = call[[z]][[2]] #
		if(length(tmp)>0) for(i in 1:length(tmp)) msk[z,] = msk[z,] + (names(pp) == tmp[i])#
	}#
	if(length(ss)==1) ss = c(ss,ss)  # convert scalar homozygote into a vector length 2#
	xss = (names(pp)==ss[1]) + (names(pp)==ss[2]) # encode the two alleles of ss as a vector#
	lrn = 1#
	for(z in 1:length(call)){ #
		for(u in 1:length(pp)) if((xss[u]>0) & (msk[z,u]==0)){ #goes through each allele at locus (for a given replicate) if suspect has allele and allele is not in mask position#
			if(csp[z,u]==0) lrn = lrn * kdrop(a,d,xss[u])  # contribution from dropouts#
			else lrn = lrn * (1-kdrop(a,d,xss[u])) # contribution from non-dropouts#
		}#
		din = csp[z,]*(xss==0) # vector indicating dropin alleles#
		#pps = pp/(1-sum(pp[msk[z,]])) # allele proportions conditional on non-masking # DOES THIS LOOK FUNNY?  I think it should be pp/(1-sum(pp*msk[z,]))#
		pps = pp/(1-sum(pp*msk[z,]))#
		lrn = lrn * ccbar^(sum(din) == 0) * cc^sum(din) * prod(pps[(1:length(pp))*din]) # contribution from dropins (= ccbar if no dropins); this isn't exactly correct if > 1 dropin, because it doesn't allow for the fact that dropin alleles are chosen without replacement (i.e. same allele can't dropin twice); but error should be small #
	}#
	lrn#
}#
#
LRdenom = function(ss,call,rel=c(0,0),n,d=0.2,a=0.5,cc=0.02){#
# evaluates denominator of LR for arbitrary relationship between ss and alternative possible contributor.  #
#
# Inputs the same as for LRnumer.#
#
# Similar to LRnumer except that all possible genotypes are considered, instead of the genotype of the alleged contributor ss and the term for each genotype is weighted by an estimate of its population proportion, p^2 or 2pipj (assuming HWE).  If there is relatedness, then we consider the possibility that an allele is shared ibd with ss, in which case we only need to account for the other allele.#
#
# First consider case of 0 alleles ibd#
	pp = p(n,ss);#
	ccbar = (1-2*cc+cc^(1+length(pp)))/(1-cc)#
	csp = matrix(0,length(call),length(pp)); msk = matrix(0,length(call),length(pp))#
	for(z in 1:length(call)){#
		tmp = call[[z]][[1]]#
		if(length(tmp)>0) for(i in 1:length(tmp)) csp[z,] = csp[z,] + (names(pp) == tmp[i]) #
		tmp = call[[z]][[2]]#
		if(length(tmp)>0) for(i in 1:length(tmp)) msk[z,] = msk[z,] + (names(pp) == tmp[i])#
	}#
	if(length(ss)==1) ss = c(ss,ss)#
	lrd = 0#
	for(i in 1:length(pp)) for(j in i:length(pp)){ # i and j specify a possible genotype for the alternative contributor#
		xij = rep(0,length(pp))#
		xij[i] = 1; xij[j] = xij[j]+1; # xij represents genotype ij as a vector#
		term = pp[i]*pp[j]; if(i != j) term = 2*term # estimate of population proportion of genotype ij#
		for(z in 1:length(call)){#
			for(u in 1:length(pp)) if((xij[u]>0) & (msk[z,u]==0)){#
				if(csp[z,u]==0) term = term * kdrop(a,d,xij[u])#
				else term = term * (1-kdrop(a,d,xij[u]))#
			} #for loop over all alleles in the set genotype that are not masked, multiply their freq by the prob of drop out or not#
			din = csp[z,]*(xij==0) # vector indicating dropin alleles#
			#pps = pp/(1-sum(pp[msk[z,]])) #again, I think this should be different#
			pps = pp/(1-sum(pp*msk[z,])) #KEL equation#
			term = term * ccbar^(sum(din) == 0) * cc^sum(din) * prod(pps[(1:length(pp))*din])#
		} #close loop over all electropherogram replicates in csp#
		lrd = lrd + term#
	}#loop over all possible genotypes#
	lrd = lrd * (1-sum(rel))  # weight by probability of 0 alleles ibd#
#
# Now 1 allele ibd#
	if(rel[1] > 0) for(i in 1:2) for(j in 1:length(pp)){#
		xsj = names(pp)==ss[i]  # choose an allele of s to be the ibd allele#
		xsj[j] = xsj[j]+1 # assign another allele to the genotype of the alternative contributor (related to ss)#
		term = pp[j]#
		for(z in 1:length(call)){#
			for(u in 1:length(pp)) if((xsj[u]>0) & (msk[z,u]==0)){#
				if(csp[z,u]==0) term = term * kdrop(a,d,xsj[u])#
				else term = term * (1-kdrop(a,d,xsj[u]))#
			}#
			din = csp[z,]*(xsj==0)#
			#pps = pp/(1-sum(pp[msk[z,]])) #
			pps = pp/(1-sum(pp*msk[z,])) #KEL equation#
			term = term * ccbar^(sum(din) == 0) * cc^sum(din) * prod(pps[(1:length(pp))*din]) #
		}#
		lrd = lrd + rel[1]/2 * term  # rel[1] is divided by 2 because of two possibilities for the ibd allele#
	}#
	lrd#
}
R commands to compute LR for for Identifiler for a single source, or two or three person mix. This will work with all R functions for LR's with dropout. This has been successfuly run with...#
#
# LR1unk_KEL_nosamp#
# LR2unk_KEL_fix_nosamp_fixIBD.R#
# LR3unk_KEL_fix_nosamp_noIBD.R#
#
#R code by David Balding, updated and modified by Kirk Lohmueller#
#
#Need to load the R function (either "LR3unk_KEL_fix_nosamp_noIBD"...) first.  THen copy and paste this stuff into R to call the functions.  Note, need to manually input the alleles and change the paths to the allele freq files.#
#
#Note, all individuals are assumed to be unrelated here.#
#
#The analyst can use any allele frequency table, although they need to be in a specific configuration expected by this program. Here we use John Butler's allele frequencies in tables; the user will have to insert the correct path to each allele table per locus. #
#
# This version allows for the possibility that a stutter peak recorded in the epg could be masking a minor component allele; allowing for masking by stutter tends to reduce the LR, since it allows more possibilities for alternative contributors of the minor component.#
#
# The variable "callXX" for locus XX is a list of replicate calls, each of length 1 here as there are no replicates.  The element of this outer list is a list of length two, corresponding to the alleles of [[1]] crime scene profile (csp) alleles [[2]] masking alleles, due either directly to a major/assumed donor or a stutter from one of these alleles.  Old Comment: the first list has the minor alleles that are not from an "assumed contributor," and can be any number of alleles, dependent on the R functions for which it will serve as input data.  Any alleles that 1) ARE from an assumed contributor, OR were 2) in a stutter position, AND 3) above the detection threshold, AND 4) below the stutter threshold would go where the word "NULL" is.#
#
# Casename:#
#
# Item #:#
#
# LR # of unknown program: #
#
dg = c(0.05) #Put the DO probs here#
a = 0.5     # set value between 0 and 1#
cc = 0.01	# set value between 0 and 1 #this is Din#
rel = c(0,0)  # relatedness: probability that alternate possible contributor has 1 and 2 alleles ibd with suspected contributor; kept at (0,0) for all analyses here#
#
race = 1 # 1 = Afr-Am; 3 = Cauc; 5 = Hisp;#
#
csf = read.table("/Volumes/Inman Drive 2 1Tb/Dropbox/KKKN/Statistics_DO programs/Frequency tables/CSF_B.count.csv",head=T,sep=",")#
ncsf = csf[,race]			# allele counts#
names(ncsf) = csf[,2]		# allele names#
sscsf = c("9","12")#
callcsf = list(list(c("9","12"),c("10","11"))) #
all_checkcsf<-c(unlist(callcsf),sscsf)#
ncsf<-rare_adjust(all_checkcsf,ncsf) #
nmr = LRnumer(sscsf,callcsf,ncsf,dg,a,cc)#
LRcsf = nmr/(nmr*rel[2]+LRdenom(sscsf,callcsf,rel,ncsf,dg,a,cc))#
mx = max(LRcsf)#
#
d2 = read.table("/Volumes/Inman Drive 2 1Tb/Dropbox/KKKN/Statistics_DO programs/Frequency tables/D2_B.count.csv",head=T,sep=",")#
nd2 = d2[,race]#
names(nd2) = d2[,2]		# allele names#
ssd2 = c("18","19")#
calld2 = list(list(c("18","19"),c("22","23"))) #
all_checkd2<-c(unlist(calld2),ssd2)#
nd2<-rare_adjust(all_checkd2,nd2)#
nmr = LRnumer(ssd2,calld2,nd2,dg,a,cc)#
LRd2 = nmr/(nmr*rel[2]+LRdenom(ssd2,calld2,rel,nd2,dg,a,cc))#
mx = max(mx,LRd2)#
#
totLR<-LRcsf*LRd2#
#
#write the per-locus LRs to a file:#
locus_LRs<-rbind(dg,LRcsf,LRd2,totLR)#
#
#write output file:#
write.table(locus_LRs,"/Users/keithMacPro/Documents/Windows shared folder/Window application files/Lab Retriever Testing/Test 1 2 loci/Test_1_2_loci_Rresult.txt",append=TRUE,quote=FALSE,sep="\t",col.names=FALSE)#
#
date()
